#!/usr/bin/python
# Copyright (c) 2012, Red Hat, Inc
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the
#    distribution.
# 3. Neither the name of Red Hat nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# Authors:
#   Stanislav Ochotnicky <sochotnicky@redhat.com>
#

import json
import os
import re
import signal
import sys
import traceback
import subprocess

from lxml import etree

from javapackages import POM
from javapackages.depmap import Depmap, MetadataInvalidException
from javapackages.artifact import Artifact, ProvidedArtifact, SkippedArtifact, Dependency

XMVN_RESOLVE_PATH='/usr/bin/xmvn-resolve'

def resolve_artifact(coordinates):
    # TODO: add support for namespaces
    outfile = open("/dev/null", 'w')
    procargs = [XMVN_RESOLVE_PATH, coordinates]
    proc = subprocess.Popen(procargs, shell=False, stdout=outfile)
    out = proc.communicate()[0]
    ret = proc.wait()
    if ret:
        return False
    return True

def process_java_version(version_string):
    version = version_string.split('.')
    if len(version) != 2:
        # if we don't have major.minor format, just ignore version
        raise ValueError("Required Java version not in major.minor format")
    major = int(version[0])
    minor = int(version[1])
    if major > 1 or minor > 5:
        return "1:{0}.{1}".format(major, minor)
    else:
        return "{0}.{1}".format(major, minor)


def get_config():
    if 'JAVACONFDIRS' in os.environ:
        config_paths = os.environ['JAVACONFDIRS'].split(os.pathsep)
    else:
        config_paths = ['%{javaconfdir}']

    new_config = {}
    for config_path in config_paths:
        try:
            file_path = os.path.join(config_path, 'javapackages-config.json')
            with open(file_path) as config_file:
                config = json.load(config_file)['maven.req']
                filters = set(new_config.get('filter_requires', ()))
                filters = filters.union(config.get('filter_requires', ()))
                new_config.update(config)
                new_config['filter_requires'] = filters
        except (OSError, IOError):
            raise Exception('Cannot load config file {0}.'.format(config_path))
    return new_config


def is_it_pom_only_pkg(metadata_path):
    """ Check if the package contains only POM file and no JARs """
    metadata = Depmap(metadata_path)
    provided = metadata.get_provided_artifacts()

    for a in provided:
        if a.extension != "pom":
            return False
    return True


class TagBuilder(object):
    def __init__(self, filelist=None):
        if filelist == None:
            filelist = sys.stdin

        self.config = get_config()

        paths = [line.rstrip() for line in filelist.readlines()]
        self.provided_artifacts = []
        self.skipped_artifacts = []
        if paths:
            # let's first read all fragment files for provided artifacts
            self.fragment_dir = os.path.dirname(paths[0])
            fpaths = []
            for dirname, _, filenames in os.walk(self.fragment_dir):
                for filename in filenames:
                    if filename.endswith(".pom"):
                        continue
                    fpaths.append(os.path.join(dirname, filename))

            self.pom_dir = paths[0].rsplit('/', 2)[0]
            self.pom_dir = os.path.join(self.pom_dir, "maven-poms")
            ppaths = []
            for dirname, _, filenames in os.walk(self.pom_dir):
                for filename in filenames:
                    ppaths.append(os.path.join(dirname, filename))

            depmap = Depmap(fpaths)
            self.provided_artifacts.extend(depmap.get_provided_artifacts())
            self.skipped_artifacts.extend(depmap.get_skipped_artifacts())

        if os.path.exists(XMVN_RESOLVE_PATH):
            if is_it_pom_only_pkg(paths[0]):
                self.__generate_requires_from_pom(ppaths[0])

        for path in paths:
            if path.endswith(".pom"):
                continue
            self.print_mvn_requires(path)

    def __is_provided_by_subpackage(self, dependency):
        for provided in self.provided_artifacts:
           if (provided.groupId == dependency.groupId and
               provided.artifactId == dependency.artifactId and
               provided.classifier == dependency.classifier and
               provided.extension == dependency.extension):
                return provided.version
        return None


    def __generate_requires_from_pom(self, pomfile):
        pom = POM(pomfile)
        plugins = pom.get_plugins()
        extensions = pom.get_extensions()
        pgid = pom.parentGroupId
        paid = pom.parentArtifactId
        pver = pom.parentVersion

        unresolvable = []

        # TODO: compat versions?
        for p in plugins:
            # TODO: namespaces
            plug = Dependency(p.groupId, p.artifactId, requestedVersion=p.version)
            aver = self.__is_provided_by_subpackage(plug)
            if resolve_artifact(plug.get_mvn_str()):
                print(plug.get_rpm_str())
            elif aver is not None:
                print("{rpmstr} = {version}".format(rpmstr=plug.get_rpm_str(), version=aver))
            else:
                unresolvable.append(plug.get_mvn_str())
            for pd in p.dependencies:
                # TODO: namespaces
                dep = Dependency(pd.groupId, pd.artifactId, requestedVersion=pd.version)
                if resolve_artifact(dep.get_mvn_str()):
                    print(dep.get_rpm_str())
                else:
                    unresolvable.append(plug.get_mvn_str())

        for e in extensions:
            # TODO: namespaces
            ext = Dependency(e.groupId, e.artifactId, requestedVersion=e.version)
            aver = self.__is_provided_by_subpackage(ext)
            if resolve_artifact(ext.get_mvn_str()):
                print(ext.get_rpm_str())
            elif aver is not None:
                print("{rpmstr} = {version}".format(rpmstr=ext.get_rpm_str(), version=aver))
            else:
                unresolvable.append(plug.get_mvn_str())

        if paid and pver:
            parent_dep = Dependency(pgid, paid, requestedVersion=pver, extension="pom")
            aver = self.__is_provided_by_subpackage(parent_dep)
            if resolve_artifact(parent_dep.get_mvn_str()):
                # TODO: namespaces
                print(parent_dep.get_rpm_str())
            elif aver is not None:
                print("{rpmstr} = {version}".format(rpmstr=parent_dep.get_rpm_str(), version=aver))
            else:
                unresolvable.append(parent_dep.get_mvn_str())

        if unresolvable:
            raise Exception("Unable to generate requires on unresolvable artifact{}: {}"
                            .format('s' if len(unresolvable) > 1 else '', ", ".join(unresolvable)))


    def __generate_java_requires(self, depmap):
        requires = set()
        for rule_name, fn in (('java_requires', Depmap.get_java_requires),
                              ('java_devel_requires', Depmap.get_java_devel_requires)):
            rules = self.config[rule_name]
            if not rules.get('skip', False):
                required_version = fn(depmap)
                if required_version:
                    version_string = process_java_version(required_version)
                    parts = {'pkg': rules['package_name'],
                             'op': rules.get('cmp_operator', '>='),
                             'version': version_string}
                    requires.add("{pkg} {op} {version}".format(**parts))
                elif rules['always_generate']:
                    requires.add(rules['package_name'])
        return requires

    def __is_dep_on_same_package(self, dependency, depmap):
        # TODO: what about requires on same compat and non-compat deps in same
        # package?
        # TODO: this duplicates code down below a bit, refactoring needed
        for provided in depmap.get_provided_artifacts():
            if (provided.groupId == dependency.groupId and
                provided.artifactId == dependency.artifactId and
                provided.classifier == dependency.classifier and
                provided.extension == dependency.extension and
                provided.namespace == dependency.namespace):
                if dependency.resolvedVersion and provided.is_compat():
                    # does it match one of provided compat?
                    for compatVer in provided.compatVersions:
                        if dependency.resolvedVersion == compatVer:
                            return True
                elif (not dependency.resolvedVersion and
                    not provided.is_compat()):
                    return True
        return False


    def filter_requires(self, requires):
        filters = self.config.get('requires_filter', [])
        filtered = set()
        regexes = []
        for filt in filters:
            artifact_glob = re.sub(r'\\\*', '.*', re.escape(filt))
            regexes.append(re.compile(r'^{}(\s*[<>=].*)?$'.format(artifact_glob)))
            regexes.append(re.compile(r'mvn\({0}\)'.format(artifact_glob)))
        for req in requires:
            if not any([regex.search(req) for regex in regexes]):
                filtered.add(req)
        return filtered

    def print_mvn_requires(self, path):
        depmap = Depmap(path)
        skipped_but_required = []
        requires = set()

        for provided in depmap.get_provided_artifacts():
            if provided.namespace:
                requires.add("{ns}-runtime".format(ns=provided.namespace))
            else:
                requires.add("jpackage-utils")

        unknown_deps = []
        for dependency in depmap.get_required_artifacts():
            if dependency.version == "UNKNOWN":
                unknown_deps.append(dependency)
                continue
            for skipped in self.skipped_artifacts:
                if (skipped.groupId == dependency.groupId and
                    skipped.artifactId == dependency.artifactId and
                    skipped.classifier == dependency.classifier and
                    skipped.extension == dependency.extension):
                    skipped_but_required.append(dependency)
            for provided in self.provided_artifacts:
                if (provided.groupId == dependency.groupId and
                    provided.artifactId == dependency.artifactId and
                    provided.classifier == dependency.classifier and
                    provided.extension == dependency.extension and
                    provided.namespace == dependency.namespace):

                    if dependency.resolvedVersion and provided.is_compat():
                        # does it match one of provided compat?
                        for compatVer in provided.compatVersions:
                            if dependency.resolvedVersion == compatVer:
                                break
                        else:
                            # none of versions matched so we depend on a
                            # different package in fact
                            continue
                    elif (not dependency.resolvedVersion and
                          not provided.is_compat()):
                        pass
                    else:
                        # one is compatibility the other is not
                        continue

                    if not self.__is_dep_on_same_package(dependency, depmap):
                        # requires on subpackages are always versioned
                        requires.add("{rpmstr} = {version}".format(
                            rpmstr=dependency.get_rpm_str(),
                            version=provided.version))

                    break
            else:
                # TODO: remove when not needed
                # do not generate requires like "a:b:pom:" yet
                if dependency.extension == "pom":
                    dependency.extension = ""
                requires.add(dependency.get_rpm_str(dependency.version))

        if unknown_deps:
            unknown_msg = "Following dependencies were not resolved and " \
                          "requires cannot be generated. Either remove the " \
                          "dependency from pom.xml or add proper packages to " \
                          "BuildRequires:\n"
            for unknown in unknown_deps:
                required_by = self.find_what_requires(unknown)
                if required_by:
                    unknown_msg += "{art} required by {req}\n".format(art=unknown,
                                                                      req=required_by)
                else:
                    unknown_msg += "{art}\n".format(art=unknown)
            raise Exception(unknown_msg)

        if skipped_but_required:
            skipped_msg = "Following artifacts were built " \
                          "but are not being installed however other " \
                          "artifacts require them:\n"
            for skipped in skipped_but_required:
                required_by = self.find_what_requires(skipped)
                if required_by:
                    skipped_msg += "{art} required by {req}\n".format(art=skipped,
                                                                      req=required_by)
                else:
                    skipped_msg += "{art}\n".format(art=skipped)
            skipped_msg += "\nEither package these artifacts or do not "\
                           "build them. To package them call %mvn_package "\
                           "in %prep.\n"
            raise Exception(skipped_msg)

        requires.update(self.__generate_java_requires(depmap))

        requires = self.filter_requires(requires)

        for req in requires:
            print(req)

    def find_what_requires(self, artifact):
        """
        Determine which artifact requires given artifact. This is an attempt to
        find the artifact by guessing where the pom might be and going through
        its dependencies. It is not meant to be reliable or pretty, just to
        print more descriptive error messages when we can. If it cannot find
        anything, returns None.
        """
        try:
            pom_dir = os.path.join(self.fragment_dir, '..', 'maven-poms')
            for dirname, _, filenames in os.walk(pom_dir):
                for filename in filenames:
                    if filename.endswith(".pom"):
                        pomfile = os.path.join(dirname, filename)
                        pom = etree.parse(pomfile)
                        pom_obj = POM(pomfile)
                        for elem in pom.getiterator():
                            if hasattr(elem.tag, 'startswith') and elem.tag.startswith('{'):
                                elem.tag = elem.tag[elem.tag.find('}') + 1:]
                        dependencies = pom.xpath('/project/dependencies/dependency')
                        for dep in dependencies:
                            dep_artifact = Artifact.from_xml_element(dep)
                            scope = dep.find('./scope')
                            if scope is not None and scope.text.strip() not in \
                                    ('compile', 'runtime'):
                                if not (scope == 'test' and pom_obj.packaging == 'pom'):
                                    continue
                            if compare_artifacts(artifact, dep_artifact):
                                return "{g}:{a}".format(g=pom_obj.groupId,
                                                        a=pom_obj.artifactId)
        except Exception:
            pass


def compare_artifacts(art1, art2):
    return (art1.artifactId == art2.artifactId and
            art1.groupId == art2.groupId)


if __name__ == "__main__":
    try:
        builder = TagBuilder ()
    except Exception:
        traceback.print_exc(file=sys.stderr)
        # rpmbuild ignores non-zero exit codes but this that is bad. Make sure
        # the build fails and doesn't silently ignore problems
        os.kill(os.getppid(), signal.SIGTERM)
