#!/usr/bin/python
# Copyright (c) 2012, Red Hat, Inc
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the
#    distribution.
# 3. Neither the name of Red Hat nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# Authors:
#   Stanislav Ochotnicky <sochotnicky@redhat.com>
#

import os
import sys
import signal
import traceback

from lxml import etree

from javapackages import POM
from javapackages.depmap import Depmap, MetadataInvalidException
from javapackages.artifact import Artifact, ProvidedArtifact, SkippedArtifact, Dependency

class TagBuilder:
    def __init__ (self, filelist=None):
        if filelist == None:
            filelist = sys.stdin
        paths = map (lambda x: x.rstrip (), filelist.readlines ())
        self.provided_artifacts = []
        self.skipped_artifacts = []
        if paths:
            # let's first read all fragment files for provided artifacts
            self.fragment_dir = os.path.dirname(paths[0])
            for dirname, dirnames, filenames in os.walk(self.fragment_dir):
                for filename in filenames:
                    if filename.endswith(".pom"):
                        continue
                    try:
                        depmap = Depmap(os.path.join(dirname, filename))
                        self.provided_artifacts.extend(depmap.get_provided_artifacts())
                        self.skipped_artifacts.extend(depmap.get_skipped_artifacts())
                    except MetadataInvalidException:
                        # let's ignore if some other files are incorrect'
                        pass
        for path in paths:
            if path.endswith(".pom"):
                continue
            self.print_mvn_requires(path)

    def __process_jvm_req(self, name, version):
        if not version:
            return
        try:
            jsplit = version.split('.')
            if len(jsplit) != 2:
                # if we don't have major.minor format, just ignore version
                raise ValueError("Required Java version not in major.minor format")
            major = int(jsplit[0])
            minor = int(jsplit[1])
            if major > 1 or minor > 5:
                print("{name} >= 1:{major}.{minor}".format(name=name,
                                                           major=major,
                                                           minor=minor))
            else:
                print("{name} >= {major}.{minor}".format(name=name,
                                                         major=major,
                                                         minor=minor))
        except ValueError:
            # what? not a numbered major/minor java release?
            print(name)


    def print_mvn_requires(self, path):
        depmap = Depmap(path)
        skipped_but_required = []
        base_package_requires=set()

        for provided in depmap.get_provided_artifacts():
            if provided.namespace:
                base_package_requires.add("{ns}-runtime".format(ns=provided.namespace))
            else:
                base_package_requires.add("jpackage-utils")
        for basereq in base_package_requires:
            print basereq

        unknown_deps = []
        for dependency in depmap.get_required_artifacts():
            if dependency.version == "UNKNOWN":
                unknown_deps.append(dependency)
                continue
            for skipped in self.skipped_artifacts:
                if (skipped.groupId == dependency.groupId and
                    skipped.artifactId == dependency.artifactId and
                    skipped.classifier == dependency.classifier and
                    skipped.extension == dependency.extension):
                    skipped_but_required.append(dependency)
            for provided in self.provided_artifacts:
                if (provided.groupId == dependency.groupId and
                    provided.artifactId == dependency.artifactId and
                    provided.classifier == dependency.classifier and
                    provided.extension == dependency.extension and
                    provided.namespace == dependency.namespace):

                    if dependency.resolvedVersion:
                        if not provided.is_compat():
                            # dependency is compat but provides is not
                            continue

                        # does it match one of provided compat?
                        for compatVer in provided.compatVersions:
                            if dependency.resolvedVersion == compatVer:
                                break
                        else:
                            # none of versions matched so we depend on a
                            # different package in fact
                            continue

                    # requires on subpackages are always versioned
                    print("{rpmstr} = {version}".format(
                        rpmstr=dependency.get_rpm_str(dependency.resolvedVersion),
                        version=provided.version))
                    break
            else:
                # TODO: remove when not needed
                # do not generate requires like "a:b:pom:" yet
                if dependency.extension == "pom":
                    dependency.extension = ""
                print(dependency.get_rpm_str(dependency.version))

        if unknown_deps:
            unknown_msg = "Following dependencies were not resolved and " \
                          "requires cannot be generated. Either remove the " \
                          "dependency from pom.xml or add proper packages to " \
                          "BuildRequires:\n"
            for unknown in unknown_deps:
                required_by = self.find_what_requires(unknown)
                if required_by:
                    unknown_msg += "{art} required by {req}\n".format(art=unknown,
                                                                      req=required_by)
                else:
                    unknown_msg += "{art}\n".format(art=unknown)
            raise Exception(unknown_msg)

        if skipped_but_required:
            skipped_msg = "Following artifacts were built " \
                          "but are not being installed however other " \
                          "artifacts require them:\n"
            for skipped in skipped_but_required:
                required_by = self.find_what_requires(skipped)
                if required_by:
                    skipped_msg += "{art} required by {req}\n".format(art=skipped,
                                                                      req=required_by)
                else:
                    skipped_msg += "{art}\n".format(art=skipped)
            skipped_msg += "\nEither package these artifacts or do not "\
                           "build them. To package them call %mvn_package "\
                           "in %prep.\n"
            raise Exception(skipped_msg)

        reqs = {'java-headless': depmap.get_java_requires(),
                'java-devel': depmap.get_java_devel_requires()}
        for name, version in reqs.iteritems():
            self.__process_jvm_req(name, version)

    def find_what_requires(self, artifact):
        """
        Determine which artifact requires given artifact. This is an attempt to
        find the artifact by guessing where the pom might be and going through
        its dependencies. It is not meant to be reliable or pretty, just to
        print more descriptive error messages when we can. If it cannot find
        anything, returns None.
        """
        try:
            pom_dir = os.path.join(self.fragment_dir, '..', 'maven-poms')
            for dirname, _, filenames in os.walk(pom_dir):
                for filename in filenames:
                    if filename.endswith(".pom"):
                        pomfile = os.path.join(dirname, filename)
                        pom = etree.parse(pomfile)
                        pom_obj = POM(pomfile)
                        for elem in pom.getiterator():
                            if hasattr(elem.tag, 'startswith') and elem.tag.startswith('{'):
                                elem.tag = elem.tag[elem.tag.find('}') + 1:]
                        dependencies = pom.xpath('/project/dependencies/dependency')
                        for dep in dependencies:
                            dep_artifact = Artifact.from_xml_element(dep)
                            scope = dep.find('./scope')
                            if scope is not None and scope.text.strip() not in \
                                    ('compile', 'runtime'):
                                if not (scope == 'test' and pom_obj.packaging == 'pom'):
                                    continue
                            if compare_artifacts(artifact, dep_artifact):
                                return "{g}:{a}".format(g=pom_obj.groupId,
                                                        a=pom_obj.artifactId)
        except Exception:
            pass


def compare_artifacts(art1, art2):
    return (art1.artifactId == art2.artifactId and
            art1.groupId == art2.groupId)


if __name__ == "__main__":
    try:
        builder = TagBuilder ()
    except Exception:
        traceback.print_exc(file=sys.stderr)
        # rpmbuild ignores non-zero exit codes but this that is bad. Make sure
        # the build fails and doesn't silently ignore problems
        os.kill(os.getppid(), signal.SIGTERM)
