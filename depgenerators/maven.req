#!/usr/bin/python
# Copyright (c) 2014, Red Hat, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the
#    distribution.
# 3. Neither the name of Red Hat nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# Authors:
#   Stanislav Ochotnicky <sochotnicky@redhat.com>
#   Michal Srb <msrb@redhat.com>

import json
import os
import re
import signal
import sys
import traceback
import subprocess

from lxml import etree

from javapackages.common.config import get_configs
from javapackages.maven.pom import POM
from javapackages.maven.artifact import Artifact
from javapackages.metadata.metadata import Metadata, MetadataInvalidException
from javapackages.metadata.artifact import MetadataArtifact
from javapackages.metadata.dependency import MetadataDependency
from javapackages.xmvn.xmvn_resolve import XMvnResolve, ResolutionRequest, ResolutionResult


def process_java_version(version_string):
    version = version_string.split('.')
    if len(version) != 2:
        # if we don't have major.minor format, just ignore version
        raise ValueError("Required Java version not in major.minor format")
    major = int(version[0])
    minor = int(version[1])
    if major > 1 or minor > 5:
        return "1:{0}.{1}".format(major, minor)
    else:
        return "{0}.{1}".format(major, minor)


def get_config():
    new_config = {}
    configs = get_configs(['%{javaconfdir}'])
    for config_file in configs:
        config = config_file['maven.req']
        filters = set(new_config.get('filter_requires', ()))
        filters = filters.union(config.get('filter_requires', ()))
        new_config.update(config)
        new_config['filter_requires'] = filters
    return new_config


def is_it_pom_only_pkg(metadata_path):
    """ Check if the package contains only POM file and no JARs """
    metadata = Metadata(metadata_path)
    provided = metadata.get_provided_artifacts()

    for a in provided:
        if a.extension != "pom":
            return False
    return True


class TagBuilder(object):
    def __init__(self, filelist=None):
        if filelist == None:
            filelist = sys.stdin

        self.config = get_config()

        paths = [line.rstrip() for line in filelist.readlines()]
        self.provided_artifacts = []
        self.skipped_artifacts = []
        if paths:
            # let's first read all metadata files for provided artifacts
            self.metadata_dir = os.path.dirname(paths[0])
            metadata_paths = []
            for dirname, _, filenames in os.walk(self.metadata_dir):
                for filename in filenames:
                    if filename.endswith(".pom"):
                        continue
                    metadata_paths.append(os.path.join(dirname, filename))

            metadata = Metadata(metadata_paths)
            self.provided_artifacts.extend(metadata.get_provided_artifacts())
            self.skipped_artifacts.extend(metadata.get_skipped_artifacts())

            # list of all installed POM files
            # TODO: this should be probably removed
            self.pom_dir = paths[0].rsplit('/', 2)[0]
            self.pom_dir = os.path.join(self.pom_dir, "maven-poms")
            ppaths = []
            for dirname, _, filenames in os.walk(self.pom_dir):
                for filename in filenames:
                    ppaths.append(os.path.join(dirname, filename))

        # try to generate R from POM only (sub)packages
        if os.path.exists(XMvnResolve._load_path_from_config()):
            if is_it_pom_only_pkg(paths[0]):
                poms = self.__find_poms_for_metadata(ppaths, paths[0])
                for p in poms:
                    self.__generate_requires_from_pom(p)


        for path in paths:
            if path.endswith(".pom"):
                continue
            self.print_mvn_requires(path)

    # TODO: move functions like this to some POMUtils, or similar module
    def __find_poms_for_metadata(self, pom_paths, metadata_path):
        poms = []
        depmap = Metadata([metadata_path])
        provided = depmap.get_provided_artifacts()
        for prov in provided:
            for p in pom_paths:
                pom = POM(p)
                if (pom.groupId == prov.groupId and
                    pom.artifactId == prov.artifactId and
                    pom.version == prov.version):

                    poms.append(pom)
                    break
        return poms

    def __generate_requires_from_pom(self, pom):
        plugins = pom.plugins
        extensions = pom.extensions
        pgid = pom.parentGroupId
        paid = pom.parentArtifactId
        pver = pom.parentVersion

        deps = plugins + extensions
        unresolvable = []

        reqs = []
        for d in deps:
            reqs.append(ResolutionRequest(d.groupId, d.artifactId, version=d.version))
        results = XMvnResolve.process_raw_request(reqs)
        for i, r in enumerate(results):
            dep = MetadataDependency(deps[i].groupId, deps[i].artifactId, requestedVersion=deps[i].version)
            if not r:
                unresolvable.append(dep)
                continue
            if r.compatVersion != "SYSTEM":
                dep.resolvedVersion = r.compatVersion
            if r.namespace:
                dep.namespace = r.namespace
            dver = dep.is_provided_by(self.provided_artifacts)[1]
            if dver is not None:
                print(dep.get_rpm_str(pkgver=dver))
                continue
            print(dep.get_rpm_str())

        if paid:
            if not pver:
                raise Exception("Unable to generate requires for artifact {}:{},".format(POM.groupId, POM.artifactId),
                                "because its parent POM {}:{} has unknown version".format(pgid, paid))

            req = ResolutionRequest(pgid, paid, extension="pom")
            r = XMvnResolve.process_raw_request([req])[0]
            dep = MetadataDependency(pgid, paid, requestedVersion=pver, extension="pom")

            dver = dep.is_provided_by(self.provided_artifacts)[1]
            if not r:
                unresolvable.append(dep)
            else:
                if r.compatVersion != "SYSTEM":
                    dep.resolvedVersion = r.compatVersion
                if r.namespace:
                    dep.namespace = r.namespace
                if dver is not None:
                    print(dep.get_rpm_str(pkgver=dver))
                else:
                    print(dep.get_rpm_str())

        if unresolvable:
            raise Exception("Unable to generate requires on unresolvable artifacts: {}"
                            .format(", ".join([x.get_mvn_str() for x in unresolvable])))

    def __generate_java_requires(self, metadata):
        requires = set()
        for rule_name, fn in (('java_requires', Metadata.get_java_requires),
                              ('java_devel_requires', Metadata.get_java_devel_requires)):
            rules = self.config[rule_name]
            if not rules.get('skip', False):
                required_version = fn(metadata)
                if required_version:
                    version_string = process_java_version(required_version)
                    parts = {'pkg': rules['package_name'],
                             'op': rules.get('cmp_operator', '>='),
                             'version': version_string}
                    requires.add("{pkg} {op} {version}".format(**parts))
                elif rules['always_generate']:
                    requires.add(rules['package_name'])
        return requires

    def filter_requires(self, requires):
        filters = self.config.get('requires_filter', [])
        filtered = set()
        regexes = []
        for filt in filters:
            artifact_glob = re.sub(r'\\\*', '.*', re.escape(filt))
            regexes.append(re.compile(r'^{}(\s*[<>=].*)?$'.format(artifact_glob)))
            regexes.append(re.compile(r'mvn\({0}\)'.format(artifact_glob)))
        for req in requires:
            if not any([regex.search(req) for regex in regexes]):
                filtered.add(req)
        return filtered

    def check_deps(self, metadata):
        unresolvable = []
        for provided in metadata.get_provided_artifacts():
            try:
                checklist = provided.properties["maven.req.check.deps"]
            except KeyError:
                # nothing to check, all good
                return []
            for mvn_str in checklist.split(";"):
                dep = MetadataDependency.from_mvn_str(mvn_str)
                dep.namespace = provided.namespace
                if not dep.is_provided_by(self.provided_artifacts)[0]:
                    unresolvable.append(dep)
        return unresolvable

    def print_mvn_requires(self, path):
        metadata = Metadata(path)
        skipped_but_required = self.check_deps(metadata)
        requires = set()

        for provided in metadata.get_provided_artifacts():
            # TODO: use javapackages-config.json
            if provided.namespace:
                requires.add("{ns}-runtime".format(ns=provided.namespace))
            else:
                requires.add("jpackage-utils")

        unknown_deps = []
        for dependency in metadata.get_required_artifacts():
            if dependency.requestedVersion == "UNKNOWN":
                unknown_deps.append(dependency)
                continue
            for skipped in self.skipped_artifacts:
                if (skipped.groupId == dependency.groupId and
                    skipped.artifactId == dependency.artifactId and
                    skipped.classifier == dependency.classifier and
                    skipped.extension == dependency.extension):
                    skipped_but_required.append(dependency)

            subpkg_dep, pkgver = dependency.is_provided_by(self.provided_artifacts)
            if subpkg_dep:
                if not dependency.is_provided_by(metadata.get_provided_artifacts())[0]:
                    # requires on subpackages are always versioned
                    rpmstr = dependency.get_rpm_str(namespace=dependency.namespace,
                                                    compat=dependency.resolvedVersion,
                                                    pkgver=pkgver)
                    requires.add(rpmstr)
            else:
                rpmstr = dependency.get_rpm_str(namespace=dependency.namespace,
                                                compat=dependency.resolvedVersion)
                requires.add(rpmstr)

        if unknown_deps:
            unknown_msg = "Following dependencies were not resolved and " \
                          "requires cannot be generated. Either remove the " \
                          "dependency from pom.xml or add proper packages to " \
                          "BuildRequires:\n"
            for unknown in unknown_deps:
                required_by = self.find_what_requires(unknown)
                if required_by:
                    unknown_msg += "{art} required by {req}\n".format(art=unknown,
                                                                      req=required_by)
                else:
                    unknown_msg += "{art}\n".format(art=unknown)
            raise Exception(unknown_msg)

        if skipped_but_required:
            skipped_msg = "Following artifacts were built " \
                          "but are not being installed however other " \
                          "artifacts require them:\n"
            for skipped in skipped_but_required:
                required_by = self.find_what_requires(skipped)
                if required_by:
                    skipped_msg += "{art} required by {req}\n".format(art=skipped,
                                                                      req=required_by)
                else:
                    skipped_msg += "{art}\n".format(art=skipped)
            skipped_msg += "\nEither package these artifacts or do not "\
                           "build them. To package them call %mvn_package "\
                           "in %prep.\n"
            raise Exception(skipped_msg)

        requires.update(self.__generate_java_requires(metadata))
        requires = self.filter_requires(requires)
        for req in requires:
            print(req)

    def find_what_requires(self, artifact):
        """
        Determine which artifact requires given artifact. This is an attempt to
        find the artifact by guessing where the pom might be and going through
        its dependencies. It is not meant to be reliable or pretty, just to
        print more descriptive error messages when we can. If it cannot find
        anything, returns None.
        """
        try:
            pom_dir = os.path.join(self.metadata_dir, '..', 'maven-poms')
            for dirname, _, filenames in os.walk(pom_dir):
                for filename in filenames:
                    if filename.endswith(".pom"):
                        pomfile = os.path.join(dirname, filename)
                        pom = etree.parse(pomfile)
                        pom_obj = POM(pomfile)
                        for elem in pom.getiterator():
                            if hasattr(elem.tag, 'startswith') and elem.tag.startswith('{'):
                                elem.tag = elem.tag[elem.tag.find('}') + 1:]
                        dependencies = pom.xpath('/project/dependencies/dependency')
                        for dep in dependencies:
                            dep_artifact = Artifact.from_xml_element(dep)
                            scope = dep.find('./scope')
                            if scope is not None and scope.text.strip() not in \
                                    ('compile', 'runtime'):
                                if not (scope == 'test' and pom_obj.packaging == 'pom'):
                                    continue
                            if compare_artifacts(artifact, dep_artifact):
                                return "{g}:{a}".format(g=pom_obj.groupId,
                                                        a=pom_obj.artifactId)
        except Exception:
            pass


def compare_artifacts(art1, art2):
    return (art1.artifactId == art2.artifactId and
            art1.groupId == art2.groupId)


if __name__ == "__main__":
    try:
        builder = TagBuilder ()
    except Exception:
        traceback.print_exc(file=sys.stderr)
        # rpmbuild ignores non-zero exit codes but this that is bad. Make sure
        # the build fails and doesn't silently ignore problems
        os.kill(os.getppid(), signal.SIGTERM)
